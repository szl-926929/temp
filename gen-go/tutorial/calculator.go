// Autogenerated by Thrift Compiler (facebook)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
// @generated

package tutorial

import (
	"bytes"
	"context"
	"fmt"
	"sync"

	thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
	shared0 "github.com/suitable/gen-go/shared"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = sync.Mutex{}
var _ = bytes.Equal
var _ = context.Background

var _ = shared0.GoUnusedProtection__

type Calculator interface {
	shared0.SharedService
	//Ahh, now onto the cool part, defining a service. Services just need a name
	//and can optionally inherit from another service using the extends keyword.

	// A method definition looks like C code. It has a return type, arguments,
	// and optionally a list of exceptions that it may throw. Note that argument
	// lists and exception lists are specified using the exact same syntax as
	// field lists in struct or exception definitions.
	Ping() (err error)
	// Parameters:
	//  - Num1
	//  - Num2
	Add(num1 int32, num2 int32) (_r int32, err error)
	// Parameters:
	//  - Logid
	//  - W
	Calculate(logid int32, w *Work) (_r int32, err error)
	// This method has a oneway modifier. That means the client only makes
	// a request and does not listen for any response at all. Oneway methods
	// must be void.
	Zip() (err error)
}

type CalculatorClientInterface interface {
	thrift.ClientInterface
	// A method definition looks like C code. It has a return type, arguments,
	// and optionally a list of exceptions that it may throw. Note that argument
	// lists and exception lists are specified using the exact same syntax as
	// field lists in struct or exception definitions.
	Ping() (err error)
	// Parameters:
	//  - Num1
	//  - Num2
	Add(num1 int32, num2 int32) (_r int32, err error)
	// Parameters:
	//  - Logid
	//  - W
	Calculate(logid int32, w *Work) (_r int32, err error)
	// This method has a oneway modifier. That means the client only makes
	// a request and does not listen for any response at all. Oneway methods
	// must be void.
	Zip() (err error)
}

//Ahh, now onto the cool part, defining a service. Services just need a name
//and can optionally inherit from another service using the extends keyword.
type CalculatorClient struct {
	CalculatorClientInterface
	*shared0.SharedServiceClient
}

func (client *CalculatorClient) Open() error {
	return client.CC.Open()
}

func (client *CalculatorClient) Close() error {
	return client.CC.Close()
}

func (client *CalculatorClient) IsOpen() bool {
	return client.CC.IsOpen()
}

func NewCalculatorClientFactory(t thrift.Transport, f thrift.ProtocolFactory) *CalculatorClient {
	return &CalculatorClient{SharedServiceClient: shared0.NewSharedServiceClientFactory(t, f)}
}

func NewCalculatorClient(t thrift.Transport, iprot thrift.Protocol, oprot thrift.Protocol) *CalculatorClient {
	return &CalculatorClient{SharedServiceClient: shared0.NewSharedServiceClient(t, iprot, oprot)}
}

func NewCalculatorClientProtocol(prot thrift.Protocol) *CalculatorClient {
	return NewCalculatorClient(prot.Transport(), prot, prot)
}

// A method definition looks like C code. It has a return type, arguments,
// and optionally a list of exceptions that it may throw. Note that argument
// lists and exception lists are specified using the exact same syntax as
// field lists in struct or exception definitions.
func (p *CalculatorClient) Ping() (err error) {
	var args CalculatorPingArgs
	err = p.CC.SendMsg("ping", &args, thrift.CALL)
	if err != nil {
		return
	}
	return p.recvPing()
}

func (p *CalculatorClient) recvPing() (err error) {
	var result CalculatorPingResult
	return p.CC.RecvMsg("ping", &result)
}

// Parameters:
//  - Num1
//  - Num2
func (p *CalculatorClient) Add(num1 int32, num2 int32) (_r int32, err error) {
	args := CalculatorAddArgs{
		Num1: num1,
		Num2: num2,
	}
	err = p.CC.SendMsg("add", &args, thrift.CALL)
	if err != nil {
		return
	}
	return p.recvAdd()
}

func (p *CalculatorClient) recvAdd() (value int32, err error) {
	var result CalculatorAddResult
	err = p.CC.RecvMsg("add", &result)
	if err != nil {
		return
	}

	return result.GetSuccess(), nil
}

// Parameters:
//  - Logid
//  - W
func (p *CalculatorClient) Calculate(logid int32, w *Work) (_r int32, err error) {
	args := CalculatorCalculateArgs{
		Logid: logid,
		W:     w,
	}
	err = p.CC.SendMsg("calculate", &args, thrift.CALL)
	if err != nil {
		return
	}
	return p.recvCalculate()
}

func (p *CalculatorClient) recvCalculate() (value int32, err error) {
	var result CalculatorCalculateResult
	err = p.CC.RecvMsg("calculate", &result)
	if err != nil {
		return
	}
	if result.Ouch != nil {
		err = result.Ouch
		return
	}
	return result.GetSuccess(), nil
}

// This method has a oneway modifier. That means the client only makes
// a request and does not listen for any response at all. Oneway methods
// must be void.
func (p *CalculatorClient) Zip() (err error) {
	var args CalculatorZipArgs
	err = p.CC.SendMsg("zip", &args, thrift.ONEWAY)
	if err != nil {
		return
	}
	return
}

//Ahh, now onto the cool part, defining a service. Services just need a name
//and can optionally inherit from another service using the extends keyword.
type CalculatorThreadsafeClient struct {
	CalculatorClientInterface
	*shared0.SharedServiceThreadsafeClient
}

func (client *CalculatorThreadsafeClient) Open() error {
	client.Mu.Lock()
	defer client.Mu.Unlock()
	return client.CC.Open()
}

func (client *CalculatorThreadsafeClient) Close() error {
	client.Mu.Lock()
	defer client.Mu.Unlock()
	return client.CC.Close()
}

func (client *CalculatorThreadsafeClient) IsOpen() bool {
	client.Mu.Lock()
	defer client.Mu.Unlock()
	return client.CC.IsOpen()
}

func NewCalculatorThreadsafeClientFactory(t thrift.Transport, f thrift.ProtocolFactory) *CalculatorThreadsafeClient {
	return &CalculatorThreadsafeClient{SharedServiceThreadsafeClient: shared0.NewSharedServiceThreadsafeClientFactory(t, f)}
}

func NewCalculatorThreadsafeClient(t thrift.Transport, iprot thrift.Protocol, oprot thrift.Protocol) *CalculatorThreadsafeClient {
	return &CalculatorThreadsafeClient{SharedServiceThreadsafeClient: shared0.NewSharedServiceThreadsafeClient(t, iprot, oprot)}
}

func NewCalculatorThreadsafeClientProtocol(prot thrift.Protocol) *CalculatorThreadsafeClient {
	return NewCalculatorThreadsafeClient(prot.Transport(), prot, prot)
}

// A method definition looks like C code. It has a return type, arguments,
// and optionally a list of exceptions that it may throw. Note that argument
// lists and exception lists are specified using the exact same syntax as
// field lists in struct or exception definitions.
func (p *CalculatorThreadsafeClient) Ping() (err error) {
	p.Mu.Lock()
	defer p.Mu.Unlock()
	var args CalculatorPingArgs
	err = p.CC.SendMsg("ping", &args, thrift.CALL)
	if err != nil {
		return
	}
	return p.recvPing()
}

func (p *CalculatorThreadsafeClient) recvPing() (err error) {
	var result CalculatorPingResult
	return p.CC.RecvMsg("ping", &result)
}

// Parameters:
//  - Num1
//  - Num2
func (p *CalculatorThreadsafeClient) Add(num1 int32, num2 int32) (_r int32, err error) {
	p.Mu.Lock()
	defer p.Mu.Unlock()
	args := CalculatorAddArgs{
		Num1: num1,
		Num2: num2,
	}
	err = p.CC.SendMsg("add", &args, thrift.CALL)
	if err != nil {
		return
	}
	return p.recvAdd()
}

func (p *CalculatorThreadsafeClient) recvAdd() (value int32, err error) {
	var result CalculatorAddResult
	err = p.CC.RecvMsg("add", &result)
	if err != nil {
		return
	}

	return result.GetSuccess(), nil
}

// Parameters:
//  - Logid
//  - W
func (p *CalculatorThreadsafeClient) Calculate(logid int32, w *Work) (_r int32, err error) {
	p.Mu.Lock()
	defer p.Mu.Unlock()
	args := CalculatorCalculateArgs{
		Logid: logid,
		W:     w,
	}
	err = p.CC.SendMsg("calculate", &args, thrift.CALL)
	if err != nil {
		return
	}
	return p.recvCalculate()
}

func (p *CalculatorThreadsafeClient) recvCalculate() (value int32, err error) {
	var result CalculatorCalculateResult
	err = p.CC.RecvMsg("calculate", &result)
	if err != nil {
		return
	}
	if result.Ouch != nil {
		err = result.Ouch
		return
	}
	return result.GetSuccess(), nil
}

// This method has a oneway modifier. That means the client only makes
// a request and does not listen for any response at all. Oneway methods
// must be void.
func (p *CalculatorThreadsafeClient) Zip() (err error) {
	p.Mu.Lock()
	defer p.Mu.Unlock()
	var args CalculatorZipArgs
	err = p.CC.SendMsg("zip", &args, thrift.ONEWAY)
	if err != nil {
		return
	}
	return
}

//Ahh, now onto the cool part, defining a service. Services just need a name
//and can optionally inherit from another service using the extends keyword.
type CalculatorChannelClient struct {
	*shared0.SharedServiceChannelClient
}

func (c *CalculatorChannelClient) Close() error {
	return c.RequestChannel.Close()
}

func (c *CalculatorChannelClient) IsOpen() bool {
	return c.RequestChannel.IsOpen()
}

func (c *CalculatorChannelClient) Open() error {
	return c.RequestChannel.Open()
}

func NewCalculatorChannelClient(channel thrift.RequestChannel) *CalculatorChannelClient {
	return &CalculatorChannelClient{SharedServiceChannelClient: shared0.NewSharedServiceChannelClient(channel)}
}

// A method definition looks like C code. It has a return type, arguments,
// and optionally a list of exceptions that it may throw. Note that argument
// lists and exception lists are specified using the exact same syntax as
// field lists in struct or exception definitions.
func (p *CalculatorChannelClient) Ping(ctx context.Context) (err error) {
	args := CalculatorPingArgs{}
	var result CalculatorPingResult
	err = p.RequestChannel.Call(ctx, "ping", &args, &result)
	if err != nil {
		return
	}

	return nil
}

// Parameters:
//  - Num1
//  - Num2
func (p *CalculatorChannelClient) Add(ctx context.Context, num1 int32, num2 int32) (_r int32, err error) {
	args := CalculatorAddArgs{
		Num1: num1,
		Num2: num2,
	}
	var result CalculatorAddResult
	err = p.RequestChannel.Call(ctx, "add", &args, &result)
	if err != nil {
		return
	}

	return result.GetSuccess(), nil
}

// Parameters:
//  - Logid
//  - W
func (p *CalculatorChannelClient) Calculate(ctx context.Context, logid int32, w *Work) (_r int32, err error) {
	args := CalculatorCalculateArgs{
		Logid: logid,
		W:     w,
	}
	var result CalculatorCalculateResult
	err = p.RequestChannel.Call(ctx, "calculate", &args, &result)
	if err != nil {
		return
	}
	if result.Ouch != nil {
		err = result.Ouch
		return
	}
	return result.GetSuccess(), nil
}

// This method has a oneway modifier. That means the client only makes
// a request and does not listen for any response at all. Oneway methods
// must be void.
func (p *CalculatorChannelClient) Zip(ctx context.Context) (err error) {
	args := CalculatorZipArgs{}
	err = p.RequestChannel.Oneway(ctx, "zip", &args)
	if err != nil {
		return
	}

	return nil
}

type CalculatorProcessor struct {
	*shared0.SharedServiceProcessor
}

func NewCalculatorProcessor(handler Calculator) *CalculatorProcessor {
	self4 := &CalculatorProcessor{shared0.NewSharedServiceProcessor(handler)}
	self4.AddToProcessorMap("ping", &calculatorProcessorPing{handler: handler})
	self4.AddToProcessorMap("add", &calculatorProcessorAdd{handler: handler})
	self4.AddToProcessorMap("calculate", &calculatorProcessorCalculate{handler: handler})
	self4.AddToProcessorMap("zip", &calculatorProcessorZip{handler: handler})
	self4.AddToFunctionServiceMap("ping", "Calculator")
	self4.AddToFunctionServiceMap("add", "Calculator")
	self4.AddToFunctionServiceMap("calculate", "Calculator")
	self4.AddToFunctionServiceMap("zip", "Calculator")
	return self4
}

type calculatorProcessorPing struct {
	handler Calculator
}

func (p *CalculatorPingResult) Exception() thrift.WritableException {
	if p == nil {
		return nil
	}
	return nil
}

func (p *calculatorProcessorPing) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
	args := CalculatorPingArgs{}
	if err := args.Read(iprot); err != nil {
		return nil, err
	}
	iprot.ReadMessageEnd()
	return &args, nil
}

func (p *calculatorProcessorPing) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
	var err2 error
	messageType := thrift.REPLY
	switch result.(type) {
	case thrift.ApplicationException:
		messageType = thrift.EXCEPTION
	}
	if err2 = oprot.WriteMessageBegin("ping", messageType, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	return err
}

func (p *calculatorProcessorPing) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
	var result CalculatorPingResult
	if err := p.handler.Ping(); err != nil {
		switch err.(type) {
		default:
			x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing ping: "+err.Error(), err)
			return x, x
		}
	}
	return &result, nil
}

type calculatorProcessorAdd struct {
	handler Calculator
}

func (p *CalculatorAddResult) Exception() thrift.WritableException {
	if p == nil {
		return nil
	}
	return nil
}

func (p *calculatorProcessorAdd) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
	args := CalculatorAddArgs{}
	if err := args.Read(iprot); err != nil {
		return nil, err
	}
	iprot.ReadMessageEnd()
	return &args, nil
}

func (p *calculatorProcessorAdd) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
	var err2 error
	messageType := thrift.REPLY
	switch result.(type) {
	case thrift.ApplicationException:
		messageType = thrift.EXCEPTION
	}
	if err2 = oprot.WriteMessageBegin("add", messageType, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	return err
}

func (p *calculatorProcessorAdd) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
	args := argStruct.(*CalculatorAddArgs)
	var result CalculatorAddResult
	if retval, err := p.handler.Add(args.Num1, args.Num2); err != nil {
		switch err.(type) {
		default:
			x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing add: "+err.Error(), err)
			return x, x
		}
	} else {
		result.Success = &retval
	}
	return &result, nil
}

type calculatorProcessorCalculate struct {
	handler Calculator
}

func (p *CalculatorCalculateResult) Exception() thrift.WritableException {
	if p == nil {
		return nil
	}
	if p.Ouch != nil {
		return p.Ouch
	}
	return nil
}

func (p *calculatorProcessorCalculate) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
	args := CalculatorCalculateArgs{}
	if err := args.Read(iprot); err != nil {
		return nil, err
	}
	iprot.ReadMessageEnd()
	return &args, nil
}

func (p *calculatorProcessorCalculate) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
	var err2 error
	messageType := thrift.REPLY
	switch v := result.(type) {
	case *InvalidOperation:
		msg := CalculatorCalculateResult{Ouch: v}
		result = &msg
	case thrift.ApplicationException:
		messageType = thrift.EXCEPTION
	}
	if err2 = oprot.WriteMessageBegin("calculate", messageType, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	return err
}

func (p *calculatorProcessorCalculate) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
	args := argStruct.(*CalculatorCalculateArgs)
	var result CalculatorCalculateResult
	if retval, err := p.handler.Calculate(args.Logid, args.W); err != nil {
		switch v := err.(type) {
		case *InvalidOperation:
			result.Ouch = v
		default:
			x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing calculate: "+err.Error(), err)
			return x, x
		}
	} else {
		result.Success = &retval
	}
	return &result, nil
}

type calculatorProcessorZip struct {
	handler Calculator
}

func (p *calculatorProcessorZip) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
	args := CalculatorZipArgs{}
	if err := args.Read(iprot); err != nil {
		return nil, err
	}
	iprot.ReadMessageEnd()
	return &args, nil
}

func (p *calculatorProcessorZip) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
	var err2 error
	messageType := thrift.REPLY
	switch result.(type) {
	case thrift.ApplicationException:
		messageType = thrift.EXCEPTION
	}
	if err2 = oprot.WriteMessageBegin("zip", messageType, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	return err
}

func (p *calculatorProcessorZip) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
	if err := p.handler.Zip(); err != nil {
		switch err.(type) {
		default:
			x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing zip: "+err.Error(), err)
			return x, x
		}
	}
	return nil, nil
}

// HELPER FUNCTIONS AND STRUCTURES

type CalculatorPingArgs struct {
	thrift.IRequest
}

func NewCalculatorPingArgs() *CalculatorPingArgs {
	return &CalculatorPingArgs{}
}

type CalculatorPingArgsBuilder struct {
	obj *CalculatorPingArgs
}

func NewCalculatorPingArgsBuilder() *CalculatorPingArgsBuilder {
	return &CalculatorPingArgsBuilder{
		obj: NewCalculatorPingArgs(),
	}
}

func (p CalculatorPingArgsBuilder) Emit() *CalculatorPingArgs {
	return &CalculatorPingArgs{}
}

func (p *CalculatorPingArgs) Read(iprot thrift.Protocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CalculatorPingArgs) Write(oprot thrift.Protocol) error {
	if err := oprot.WriteStructBegin("ping_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CalculatorPingArgs) String() string {
	if p == nil {
		return "<nil>"
	}

	return fmt.Sprintf("CalculatorPingArgs({})")
}

type CalculatorPingResult struct {
	thrift.IResponse
}

func NewCalculatorPingResult() *CalculatorPingResult {
	return &CalculatorPingResult{}
}

type CalculatorPingResultBuilder struct {
	obj *CalculatorPingResult
}

func NewCalculatorPingResultBuilder() *CalculatorPingResultBuilder {
	return &CalculatorPingResultBuilder{
		obj: NewCalculatorPingResult(),
	}
}

func (p CalculatorPingResultBuilder) Emit() *CalculatorPingResult {
	return &CalculatorPingResult{}
}

func (p *CalculatorPingResult) Read(iprot thrift.Protocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CalculatorPingResult) Write(oprot thrift.Protocol) error {
	if err := oprot.WriteStructBegin("ping_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CalculatorPingResult) String() string {
	if p == nil {
		return "<nil>"
	}

	return fmt.Sprintf("CalculatorPingResult({})")
}

// Attributes:
//  - Num1
//  - Num2
type CalculatorAddArgs struct {
	thrift.IRequest
	Num1 int32 `thrift:"num1,1" db:"num1" json:"num1"`
	Num2 int32 `thrift:"num2,2" db:"num2" json:"num2"`
}

func NewCalculatorAddArgs() *CalculatorAddArgs {
	return &CalculatorAddArgs{}
}

func (p *CalculatorAddArgs) GetNum1() int32 {
	return p.Num1
}

func (p *CalculatorAddArgs) GetNum2() int32 {
	return p.Num2
}

type CalculatorAddArgsBuilder struct {
	obj *CalculatorAddArgs
}

func NewCalculatorAddArgsBuilder() *CalculatorAddArgsBuilder {
	return &CalculatorAddArgsBuilder{
		obj: NewCalculatorAddArgs(),
	}
}

func (p CalculatorAddArgsBuilder) Emit() *CalculatorAddArgs {
	return &CalculatorAddArgs{
		Num1: p.obj.Num1,
		Num2: p.obj.Num2,
	}
}

func (c *CalculatorAddArgsBuilder) Num1(num1 int32) *CalculatorAddArgsBuilder {
	c.obj.Num1 = num1
	return c
}

func (c *CalculatorAddArgsBuilder) Num2(num2 int32) *CalculatorAddArgsBuilder {
	c.obj.Num2 = num2
	return c
}

func (c *CalculatorAddArgs) SetNum1(num1 int32) *CalculatorAddArgs {
	c.Num1 = num1
	return c
}

func (c *CalculatorAddArgs) SetNum2(num2 int32) *CalculatorAddArgs {
	c.Num2 = num2
	return c
}

func (p *CalculatorAddArgs) Read(iprot thrift.Protocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CalculatorAddArgs) ReadField1(iprot thrift.Protocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Num1 = v
	}
	return nil
}

func (p *CalculatorAddArgs) ReadField2(iprot thrift.Protocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Num2 = v
	}
	return nil
}

func (p *CalculatorAddArgs) Write(oprot thrift.Protocol) error {
	if err := oprot.WriteStructBegin("add_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CalculatorAddArgs) writeField1(oprot thrift.Protocol) (err error) {
	if err := oprot.WriteFieldBegin("num1", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:num1: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Num1)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.num1 (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:num1: ", p), err)
	}
	return err
}

func (p *CalculatorAddArgs) writeField2(oprot thrift.Protocol) (err error) {
	if err := oprot.WriteFieldBegin("num2", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:num2: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Num2)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.num2 (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:num2: ", p), err)
	}
	return err
}

func (p *CalculatorAddArgs) String() string {
	if p == nil {
		return "<nil>"
	}

	num1Val := fmt.Sprintf("%v", p.Num1)
	num2Val := fmt.Sprintf("%v", p.Num2)
	return fmt.Sprintf("CalculatorAddArgs({Num1:%s Num2:%s})", num1Val, num2Val)
}

// Attributes:
//  - Success
type CalculatorAddResult struct {
	thrift.IResponse
	Success *int32 `thrift:"success,0,optional" db:"success" json:"success,omitempty"`
}

func NewCalculatorAddResult() *CalculatorAddResult {
	return &CalculatorAddResult{}
}

var CalculatorAddResult_Success_DEFAULT int32

func (p *CalculatorAddResult) GetSuccess() int32 {
	if !p.IsSetSuccess() {
		return CalculatorAddResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *CalculatorAddResult) IsSetSuccess() bool {
	return p != nil && p.Success != nil
}

type CalculatorAddResultBuilder struct {
	obj *CalculatorAddResult
}

func NewCalculatorAddResultBuilder() *CalculatorAddResultBuilder {
	return &CalculatorAddResultBuilder{
		obj: NewCalculatorAddResult(),
	}
}

func (p CalculatorAddResultBuilder) Emit() *CalculatorAddResult {
	return &CalculatorAddResult{
		Success: p.obj.Success,
	}
}

func (c *CalculatorAddResultBuilder) Success(success *int32) *CalculatorAddResultBuilder {
	c.obj.Success = success
	return c
}

func (c *CalculatorAddResult) SetSuccess(success *int32) *CalculatorAddResult {
	c.Success = success
	return c
}

func (p *CalculatorAddResult) Read(iprot thrift.Protocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CalculatorAddResult) ReadField0(iprot thrift.Protocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CalculatorAddResult) Write(oprot thrift.Protocol) error {
	if err := oprot.WriteStructBegin("add_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CalculatorAddResult) writeField0(oprot thrift.Protocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CalculatorAddResult) String() string {
	if p == nil {
		return "<nil>"
	}

	var successVal string
	if p.Success == nil {
		successVal = "<nil>"
	} else {
		successVal = fmt.Sprintf("%v", *p.Success)
	}
	return fmt.Sprintf("CalculatorAddResult({Success:%s})", successVal)
}

// Attributes:
//  - Logid
//  - W
type CalculatorCalculateArgs struct {
	thrift.IRequest
	Logid int32 `thrift:"logid,1" db:"logid" json:"logid"`
	W     *Work `thrift:"w,2" db:"w" json:"w"`
}

func NewCalculatorCalculateArgs() *CalculatorCalculateArgs {
	return &CalculatorCalculateArgs{
		W: NewWork(),
	}
}

func (p *CalculatorCalculateArgs) GetLogid() int32 {
	return p.Logid
}

var CalculatorCalculateArgs_W_DEFAULT *Work

func (p *CalculatorCalculateArgs) GetW() *Work {
	if !p.IsSetW() {
		return CalculatorCalculateArgs_W_DEFAULT
	}
	return p.W
}
func (p *CalculatorCalculateArgs) IsSetW() bool {
	return p != nil && p.W != nil
}

type CalculatorCalculateArgsBuilder struct {
	obj *CalculatorCalculateArgs
}

func NewCalculatorCalculateArgsBuilder() *CalculatorCalculateArgsBuilder {
	return &CalculatorCalculateArgsBuilder{
		obj: NewCalculatorCalculateArgs(),
	}
}

func (p CalculatorCalculateArgsBuilder) Emit() *CalculatorCalculateArgs {
	return &CalculatorCalculateArgs{
		Logid: p.obj.Logid,
		W:     p.obj.W,
	}
}

func (c *CalculatorCalculateArgsBuilder) Logid(logid int32) *CalculatorCalculateArgsBuilder {
	c.obj.Logid = logid
	return c
}

func (c *CalculatorCalculateArgsBuilder) W(w *Work) *CalculatorCalculateArgsBuilder {
	c.obj.W = w
	return c
}

func (c *CalculatorCalculateArgs) SetLogid(logid int32) *CalculatorCalculateArgs {
	c.Logid = logid
	return c
}

func (c *CalculatorCalculateArgs) SetW(w *Work) *CalculatorCalculateArgs {
	c.W = w
	return c
}

func (p *CalculatorCalculateArgs) Read(iprot thrift.Protocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CalculatorCalculateArgs) ReadField1(iprot thrift.Protocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Logid = v
	}
	return nil
}

func (p *CalculatorCalculateArgs) ReadField2(iprot thrift.Protocol) error {
	p.W = NewWork()
	if err := p.W.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.W), err)
	}
	return nil
}

func (p *CalculatorCalculateArgs) Write(oprot thrift.Protocol) error {
	if err := oprot.WriteStructBegin("calculate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CalculatorCalculateArgs) writeField1(oprot thrift.Protocol) (err error) {
	if err := oprot.WriteFieldBegin("logid", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:logid: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Logid)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.logid (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:logid: ", p), err)
	}
	return err
}

func (p *CalculatorCalculateArgs) writeField2(oprot thrift.Protocol) (err error) {
	if err := oprot.WriteFieldBegin("w", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:w: ", p), err)
	}
	if err := p.W.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.W), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:w: ", p), err)
	}
	return err
}

func (p *CalculatorCalculateArgs) String() string {
	if p == nil {
		return "<nil>"
	}

	logidVal := fmt.Sprintf("%v", p.Logid)
	var wVal string
	if p.W == nil {
		wVal = "<nil>"
	} else {
		wVal = fmt.Sprintf("%v", p.W)
	}
	return fmt.Sprintf("CalculatorCalculateArgs({Logid:%s W:%s})", logidVal, wVal)
}

// Attributes:
//  - Success
//  - Ouch
type CalculatorCalculateResult struct {
	thrift.IResponse
	Success *int32            `thrift:"success,0,optional" db:"success" json:"success,omitempty"`
	Ouch    *InvalidOperation `thrift:"ouch,1,optional" db:"ouch" json:"ouch,omitempty"`
}

func NewCalculatorCalculateResult() *CalculatorCalculateResult {
	return &CalculatorCalculateResult{}
}

var CalculatorCalculateResult_Success_DEFAULT int32

func (p *CalculatorCalculateResult) GetSuccess() int32 {
	if !p.IsSetSuccess() {
		return CalculatorCalculateResult_Success_DEFAULT
	}
	return *p.Success
}

var CalculatorCalculateResult_Ouch_DEFAULT *InvalidOperation

func (p *CalculatorCalculateResult) GetOuch() *InvalidOperation {
	if !p.IsSetOuch() {
		return CalculatorCalculateResult_Ouch_DEFAULT
	}
	return p.Ouch
}
func (p *CalculatorCalculateResult) IsSetSuccess() bool {
	return p != nil && p.Success != nil
}

func (p *CalculatorCalculateResult) IsSetOuch() bool {
	return p != nil && p.Ouch != nil
}

type CalculatorCalculateResultBuilder struct {
	obj *CalculatorCalculateResult
}

func NewCalculatorCalculateResultBuilder() *CalculatorCalculateResultBuilder {
	return &CalculatorCalculateResultBuilder{
		obj: NewCalculatorCalculateResult(),
	}
}

func (p CalculatorCalculateResultBuilder) Emit() *CalculatorCalculateResult {
	return &CalculatorCalculateResult{
		Success: p.obj.Success,
		Ouch:    p.obj.Ouch,
	}
}

func (c *CalculatorCalculateResultBuilder) Success(success *int32) *CalculatorCalculateResultBuilder {
	c.obj.Success = success
	return c
}

func (c *CalculatorCalculateResultBuilder) Ouch(ouch *InvalidOperation) *CalculatorCalculateResultBuilder {
	c.obj.Ouch = ouch
	return c
}

func (c *CalculatorCalculateResult) SetSuccess(success *int32) *CalculatorCalculateResult {
	c.Success = success
	return c
}

func (c *CalculatorCalculateResult) SetOuch(ouch *InvalidOperation) *CalculatorCalculateResult {
	c.Ouch = ouch
	return c
}

func (p *CalculatorCalculateResult) Read(iprot thrift.Protocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CalculatorCalculateResult) ReadField0(iprot thrift.Protocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CalculatorCalculateResult) ReadField1(iprot thrift.Protocol) error {
	p.Ouch = NewInvalidOperation()
	if err := p.Ouch.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ouch), err)
	}
	return nil
}

func (p *CalculatorCalculateResult) Write(oprot thrift.Protocol) error {
	if err := oprot.WriteStructBegin("calculate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CalculatorCalculateResult) writeField0(oprot thrift.Protocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CalculatorCalculateResult) writeField1(oprot thrift.Protocol) (err error) {
	if p.IsSetOuch() {
		if err := oprot.WriteFieldBegin("ouch", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ouch: ", p), err)
		}
		if err := p.Ouch.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ouch), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ouch: ", p), err)
		}
	}
	return err
}

func (p *CalculatorCalculateResult) String() string {
	if p == nil {
		return "<nil>"
	}

	var successVal string
	if p.Success == nil {
		successVal = "<nil>"
	} else {
		successVal = fmt.Sprintf("%v", *p.Success)
	}
	var ouchVal string
	if p.Ouch == nil {
		ouchVal = "<nil>"
	} else {
		ouchVal = fmt.Sprintf("%v", p.Ouch)
	}
	return fmt.Sprintf("CalculatorCalculateResult({Success:%s Ouch:%s})", successVal, ouchVal)
}

type CalculatorZipArgs struct {
	thrift.IRequest
}

func NewCalculatorZipArgs() *CalculatorZipArgs {
	return &CalculatorZipArgs{}
}

type CalculatorZipArgsBuilder struct {
	obj *CalculatorZipArgs
}

func NewCalculatorZipArgsBuilder() *CalculatorZipArgsBuilder {
	return &CalculatorZipArgsBuilder{
		obj: NewCalculatorZipArgs(),
	}
}

func (p CalculatorZipArgsBuilder) Emit() *CalculatorZipArgs {
	return &CalculatorZipArgs{}
}

func (p *CalculatorZipArgs) Read(iprot thrift.Protocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CalculatorZipArgs) Write(oprot thrift.Protocol) error {
	if err := oprot.WriteStructBegin("zip_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CalculatorZipArgs) String() string {
	if p == nil {
		return "<nil>"
	}

	return fmt.Sprintf("CalculatorZipArgs({})")
}
